
// Find all available variables here
// https://help.autodesk.com/view/MAYAUL/2020/ENU/?guid=GUID-0939A615-81AC-455C-9B23-9ECEC5835F93

// transform object vertices to world-space
uniform mat4 gWorldXf : World;

// transform object vertices to view space and project them in perspective
uniform mat4 gWvpXf : WorldViewProjection;

uniform mat4 gWorldView : ViewProjectionTranspose;

/* Data from application vertex buffer */
attribute AppData {
    vec3 inPosition   : POSITION;
    vec3 inNormal     : NORMAL;
    vec3 inColor      : COLOR0;
};

/* Data passed from vertex shader to fragment shader */
attribute ToColorPass {
    vec4 Normal         : NORMAL;
    vec4 WorldPosition  : TEXCOORD0;
    vec4 ObjectColor        : COLOR0;
};

/* Data passed from vertex shader to fragment shader */
attribute FromVert {
    vec4 Normal         : NORMAL;
    vec4 WorldPosition  : TEXCOORD0;
    vec4 ObjectColor        : COLOR0;
};

/* Data output by the fragment shader */
attribute ToScreen  {
    vec4 colorOut : COLOR0;
}

GLSLShader ShaderVertex
{
    void main() 
    {
        vec3 worldNormal = normalize(mat3(gWorldXf) * inNormal);
        Normal = vec4(worldNormal, 1.0);
        ObjectColor = vec4(inColor, 1);

        WorldPosition = gWvpXf * vec4(inPosition, 1);
        WorldPosition.z -= 0.0001;

        gl_Position = WorldPosition;
    }
}

GLSLShader ShaderColor
{
    void main()
    {
        // Object-color to light ratio
        float ratio = 0.8;
        float brightness = 0.8;
        float specularStrength = 0.2;
        float ambient = 0.2;
        int shininess = 8;

        // diffuse
        vec3 lightColor = vec3(1, 1, 1);
        vec3 norm = normalize(Normal.xyz);
        vec3 lightDir = -normalize(mat3(gWorldView) * vec3(0.5, -0.25, 1));
        float diff = max(dot(norm, lightDir), ambient);
        vec3 diffuse = diff * lightColor;

        // specular
        vec3 viewDir = lightDir;
        vec3 reflectDir = reflect(-lightDir, norm);  
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);
        vec3 specular = specularStrength * spec * lightColor;
        vec3 objectColor = ObjectColor.rgb * ratio;

        vec3 result = objectColor * diffuse + specular;
        colorOut = vec4(result * brightness, 1.0);
    }
}

technique Main
{
    pass p0
    {
        VertexShader (in AppData, out ToColorPass) = ShaderVertex;
        PixelShader (in FromVert, out ToScreen) = ShaderColor;
    }
}
